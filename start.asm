; start.asm (исправленный фрагмент)
BITS 32
extern kernel_main

global start
start:
    ; Инициализация сегментов данных
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov esp, 0x90000

    ; Вызов основной функции ядра на C
    call kernel_main

    ; --- НАЧАЛО: Индикация жизни ---
    ; Получаем адрес видеопамяти
    mov edi, 0xB8000
    ; Вычисляем смещение до последней ячейки (строка 24, столбец 79)
    ; Формат видеопамяти: [символ][атрибут][символ][атрибут]...
    ; Строка 24, столбец 79 -> Индекс = (24 * 80 + 79) * 2 = 3998 (0xF9E)
    mov ebx, 0xF9E ; Смещение в байтах до последнего символа

    mov esi, spinner_chars ; Адрес строки с символами индикатора
    mov ecx, 0 ; Индекс символа

.spin_loop:
    ; Загружаем текущий символ
    mov al, [esi + ecx]
    cmp al, 0 ; Проверяем на конец строки (нулевой байт)
    jz .reset_spinner ; Если конец, сбрасываем индекс

    ; Записываем символ в видеопамять
    mov [edi + ebx], al
    ; Записываем атрибут (цвет, например, светло-серый на черном)
    mov byte [edi + ebx + 1], 0x07

    ; Ждем немного (простая задержка)
    mov edx, 0xFFFFF ; Большое число для задержки
.delay_loop:
    dec edx
    jnz .delay_loop

    ; Переходим к следующему символу
    inc ecx
    jmp .spin_loop

.reset_spinner:
    mov ecx, 0 ; Сбрасываем индекс символа
    jmp .spin_loop

; Данные для индикатора
spinner_chars db '|/-\', 0 ; Строка с символами и завершающим нулем

; --- КОНЕЦ: Индикация жизни ---

; Если по какой-то причине индикация выше не сработала или мы вышли из нее,
; всё равно не даем процессору "улететь" в неизвестность.
; cli ; Не обязательно, если мы в защищенном режиме и не ожидаем внешних прерываний
.final_halt:
    hlt ; Останавливаем процессор до прерывания (если будет)
    jmp .final_halt ; И снова останавливаем, если hlt как-то прервался

; Если вы хотите активное ожидание вместо hlt:
; .final_loop:
;     jmp .final_loop